# -*- coding: utf-8 -*-
"""quicksort.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Hlzat1IDhYTsU1CUZhembsUGqMm_DUYc
"""

import pandas as pd
import sys

# Define o limite máximo de chamadas recursivas
sys.setrecursionlimit(1000) 

# Carrega o arquivo CSV em um dataframe do pandas
df = pd.read_csv('/content/Google-Playstore.csv')

# Separa as colunas com base na vírgula
df = df['Scraped Time'].apply(lambda x: pd.Series(str(x).split(',')))

# Define a função quicksort
def quicksort(arr, depth):
    # Caso base: se a lista tiver tamanho 1 ou menor, já está ordenada
    if len(arr) <= 1:
        return arr
    
    # Verifica se o limite máximo de profundidade da recursão foi atingido
    if depth <= 0:
        return []
    
    # Seleciona o primeiro elemento como pivô
    pivot = arr[0]
    left = []
    right = []
    # Percorre o restante da lista, colocando os elementos menores que o pivô à esquerda e os maiores à direita
    for item in arr[1:]:
        if item < pivot:
            left.append(item)
        else:
            right.append(item)
    
    # Ordena recursivamente a sublista à esquerda e a sublista à direita
    left_sorted = quicksort(left, depth-1) 
    right_sorted = quicksort(right, depth-1)
    
    # Combina as sublistas ordenadas com o pivô central e retorna o resultado
    return left_sorted + [pivot] + right_sorted

# Aplica o quicksort em cada coluna do dataframe
for col in df.columns:
    # Ordena a coluna usando o quicksort e a profundidade máxima de recursão definida
    sorted_col = quicksort(df[col].tolist(), depth=900) 
    # Preenche a lista resultante com None para ter o mesmo comprimento que o índice do DataFrame
    sorted_col += [None] * (len(df) - len(sorted_col)) 
    # Substitui a coluna original do DataFrame pela lista ordenada resultante
    df[col] = sorted_col 

# Imprime o DataFrame resultante
print(df)

"""A função quicksort é uma implementação recursiva do algoritmo de ordenação quicksort. Ela seleciona um elemento como pivô, divide a lista em duas sub-listas (à esquerda os menores que o pivô e à direita os maiores que o pivô) e ordena recursivamente cada sublista. O pivô é adicionado no centro das duas sublistas ordenadas para obter a lista final ordenada. O limite máximo de profundidade da recursão é definido para evitar um possível estouro de pilha.

Por fim, o código aplica a função quicksort em cada coluna do DataFrame e substitui a coluna original pela lista ordenada resultante. O DataFrame resultante é impresso na saída padrão.
"""